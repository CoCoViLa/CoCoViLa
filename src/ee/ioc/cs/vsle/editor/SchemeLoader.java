package ee.ioc.cs.vsle.editor;

import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.*;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

import ee.ioc.cs.vsle.util.*;
import ee.ioc.cs.vsle.vclass.*;
import ee.ioc.cs.vsle.graphics.Shape;

/**
 */
public class SchemeLoader {
	Connection connection;
	GObj obj;
	RelObj relObj;
	ObjectList objects = new ObjectList();
	ConnectionList connections = new ConnectionList();
	VPackage vPackage;

	public SchemeLoader(File file, VPackage vp) {
		this.vPackage = vp;

		// Use an instance of ourselves as the SAX event handler
		DefaultHandler handler = new PackageHandler();

		// Use the validating parser
		SAXParserFactory factory = SAXParserFactory.newInstance();

		factory.setValidating(true);
		//path = file.getParent();

		try {
			// Parse the input
			SAXParser saxParser = factory.newSAXParser();
			saxParser.parse(file, handler);
		} catch (SAXException sxe) {
			// Error generated by this application (or a parser-initialization error)
			Exception x = sxe;

			if (sxe.getException() != null) {
				x = sxe.getException();
			}
			x.printStackTrace();
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		} catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
		}
		db.p("Parsing finished");
	} // PackageParser

	// ===========================================================
	// SAX DocumentHandler methods
	// ===========================================================
	class PackageHandler extends DefaultHandler {


		public InputSource resolveEntity(java.lang.String publicId, java.lang.String systemId) throws SAXException {
			InputSource is = null;
			// order the DTD to be specified externally.
			if (systemId != null && systemId.endsWith("dtd")) {
				is = new InputSource("scheme.dtd");
			}
			return is;
		}

		public void error(SAXParseException spe) {
			// Error generated by the parser

			db.p(
				"\n** Parsing error, line " + spe.getLineNumber() + ", uri "
				+ spe.getSystemId());
			//db.p("   " + spe.getMessage());

			// Use the contained exception, if any
			Exception x = spe;

			if (spe.getException() != null) {
				x = spe.getException();
			}
			x.printStackTrace();
		}

		public void setDocumentLocator(Locator l) {// Save this to resolve relative URIs or to give diagnostics.
		}

		public void startDocument() throws SAXException {
		}

		public void endDocument() throws SAXException {
		}

		public void startElement(String namespaceURI, String lName, String qName,
								 Attributes attrs) throws SAXException {
			String element = qName;

			if (element.equals("object")) {
				String name = attrs.getValue("name");
				String type = attrs.getValue("type");
				obj = new GObj();
				obj.setName(name);
				obj.setClassName(type);
				objects.add(obj);

			}

			if (element.equals("relobject")) {
				String name = attrs.getValue("name");
				String type = attrs.getValue("type");
				relObj = new RelObj();
				relObj.setName(name);
				relObj.setClassName(type);

				objects.add(relObj);

			}


			if (element.equals("scheme")) {
				String type = attrs.getValue("package");
				if (!type.equals(vPackage.name)) {
					throw new SAXException("Scheme was built with package \"" + type + "\", load this package first");
				}
			}


			if (element.equals("properties")) {
				String x = attrs.getValue("x");
				String y = attrs.getValue("y");
				String xsize = attrs.getValue("xsize");
				String ysize = attrs.getValue("ysize");
				String width = attrs.getValue("width");
				String height = attrs.getValue("height");
				String strict = attrs.getValue("strict");

				obj.setX(Integer.parseInt(x));
				obj.setY(Integer.parseInt(y));
				obj.setXsize(Float.parseFloat(xsize));
				obj.setYsize(Float.parseFloat(ysize));
				obj.setWidth(Integer.parseInt(width));
				obj.setHeight(Integer.parseInt(height));
				obj.setStrict(Boolean.valueOf(strict).booleanValue());
			}

			if (element.equals("relproperties")) {
				String x = attrs.getValue("x");
				String y = attrs.getValue("y");
				String endX = attrs.getValue("endX");
				String endY = attrs.getValue("endY");
				String angle = attrs.getValue("angle");
				String xsize = attrs.getValue("xsize");
				String ysize = attrs.getValue("ysize");
				String width = attrs.getValue("width");
				String height = attrs.getValue("height");
				String strict = attrs.getValue("strict");

				relObj.setX(Integer.parseInt(x));
				relObj.setY(Integer.parseInt(y));
				relObj.endX = Integer.parseInt(endX);
				relObj.endY = Integer.parseInt(endY);
				relObj.angle = Double.parseDouble(angle);

				relObj.setXsize(Float.parseFloat(xsize));
				relObj.setYsize(Float.parseFloat(ysize));
				relObj.setWidth(Integer.parseInt(width));
				relObj.setHeight(Integer.parseInt(height));
				relObj.setStrict(Boolean.valueOf(strict).booleanValue());
			}


			if (element.equals("field")) {
				String name = new String(attrs.getValue("name"));
				String type = new String(attrs.getValue("type"));
				String value = attrs.getValue("value");

				ClassField cf = new ClassField();
				cf.name = name;
				cf.type = type;
				if (value != null) {
					cf.value = value;
				}
				obj.fields.add(cf);
			}

			if (element.equals("connection")) {
				String obj1 = new String(attrs.getValue("obj1"));
				String port1 = new String(attrs.getValue("port1"));
				String obj2 = new String(attrs.getValue("obj2"));
				String port2 = new String(attrs.getValue("port2"));
				Port beginPort = objects.getPort(obj1, port1);
				Port endPort = objects.getPort(obj2, port2);
				connection = new Connection(beginPort, endPort);
				beginPort.addConnection(connection);
				endPort.addConnection(connection);
				beginPort.setConnected(true);
				endPort.setConnected(true);
				connections.add(connection);
			}

			if (element.equals("point")) {
				String x = new String(attrs.getValue("x"));
				String y = new String(attrs.getValue("y"));
				connection.addBreakPoint(new Point(Integer.parseInt(x), Integer.parseInt(y)));
			}

		}

		public void endElement(String namespaceURI, String sName, String qName) throws
			SAXException {
			if (qName.equals("object")) {
				for (int j = 0; j < vPackage.classes.size(); j++) {
					PackageClass pClass = (PackageClass) vPackage.classes.get(j);
					if (pClass.name.equals(obj.className)) {

						// deep clone each separate field
						ClassField field;
						ClassField objField;
						for (int i = 0; i < pClass.fields.size(); i++) {
							field = (ClassField) pClass.fields.get(i);
							objField = (ClassField) obj.fields.get(i);
							objField.knownGraphics = field.knownGraphics;
							objField.defaultGraphics = field.defaultGraphics;

						}

						obj.ports = (ArrayList) pClass.ports.clone();

						obj.shapes = (ArrayList) pClass.graphics.shapes.clone();
						Shape shape;
						for (int i = 0; i < obj.shapes.size(); i++) {
							shape = (Shape) obj.shapes.get(i);
							obj.shapes.set(i, shape.clone());
						}

						Port port;
						for (int i = 0; i < obj.ports.size(); i++) {
							port = (Port) obj.ports.get(i);
							obj.ports.set(i, port.clone());
							port = (Port) obj.ports.get(i);
							port.setObject(obj);

							if (port.isStrict()) {
								obj.strict = true;
							}

							if (port.x + port.openGraphics.boundX < obj.portOffsetX1) {
								obj.portOffsetX1 = port.x + port.openGraphics.boundX;
							}

							if (port.y + port.openGraphics.boundY < obj.portOffsetY1) {
								obj.portOffsetY1 = port.y + port.openGraphics.boundY;
							}

							if (port.x + port.openGraphics.boundWidth > obj.width + obj.portOffsetX2) {
								obj.portOffsetX2 = Math.max((port.x + port.openGraphics.boundX + port.openGraphics.boundWidth) - obj.width, 0);
							}

							if (port.y + port.openGraphics.boundHeight > obj.height + obj.portOffsetY2) {
								obj.portOffsetY2 = Math.max((port.y + port.openGraphics.boundY + port.openGraphics.boundHeight) - obj.height, 0);
							}

							// deep clone port's connectionlist
							port.connections = (ArrayList) port.connections.clone();
						}

					}
				}
			}

			if (qName.equals("relobject")) {
				for (int j = 0; j < vPackage.classes.size(); j++) {
					PackageClass pClass = (PackageClass) vPackage.classes.get(j);
					if (pClass.name.equals(relObj.className)) {

						// deep clone each separate field
						ClassField field;
						ClassField objField;
						for (int i = 0; i < pClass.fields.size(); i++) {
							field = (ClassField) pClass.fields.get(i);
							objField = (ClassField) relObj.fields.get(i);
							objField.knownGraphics = field.knownGraphics;
							objField.defaultGraphics = field.defaultGraphics;

						}

						relObj.ports = (ArrayList) pClass.ports.clone();

						relObj.shapes = (ArrayList) pClass.graphics.shapes.clone();
						Shape shape;
						for (int i = 0; i < relObj.shapes.size(); i++) {
							shape = (Shape) relObj.shapes.get(i);
							relObj.shapes.set(i, shape.clone());
						}

						relObj.startPort = ((Port) relObj.ports.get(0));
						relObj.endPort = (Port) relObj.ports.get(1);


					}
				}
			}


			if (qName.equals("scheme")) {
                //create proper references to start and endports in all RelObjects
				//üsna valus häkk
				for (int i = 0; i < objects.size(); i++) {
					obj = (GObj) objects.get(i);
					if (obj instanceof RelObj) {
                        Port port = (Port)obj.ports.get(0);
						Connection con = (Connection)port.connections.get(0);
						((RelObj)obj).startPort.obj = con.beginPort.obj;
						port = (Port)obj.ports.get(1);
						con = (Connection)port.connections.get(0);
                        ((RelObj)obj).endPort.obj = con.endPort.obj;

					}
				}
			}
		}

		public void characters(char buf[], int offset, int len) throws SAXException {

		}

		public void ignorableWhitespace(char buf[], int offset, int len) throws SAXException {// Purposely ignore it.
		}

		public void processingInstruction(String target, String data) throws SAXException {// Purposely ignore it.
		}

	}

	/**
	 * Treat validation errors as fatal.
	 * SAX ErrorHandler method.
	 * @param e - SAXParseException.
	 * @throws org.xml.sax.SAXParseException -
	 */
	public void error(SAXParseException e) throws SAXParseException {
		//db.p(e);
	} // error

	/**
	 * Output warnings via the debug output module.
	 * SAX ErrorHandler method.
	 * @param e - SAXParseException.
	 * @throws org.xml.sax.SAXParseException -
	 */
	public void warning(SAXParseException e) throws SAXParseException {
		db.p(
			"** Warning, line " + e.getLineNumber() + ", uri "
			+ e.getSystemId());
		//db.p("   " + e.getMessage());
	} // warning

	public Scheme getScheme() {
		return new Scheme(objects, connections);
	}
}

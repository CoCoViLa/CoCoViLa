package ee.ioc.cs.vsle.editor;

import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.*;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import ee.ioc.cs.vsle.util.*;
import ee.ioc.cs.vsle.vclass.*;
/**
 */
public class SchemeLoader {
	Connection connection;
	GObj obj;
	ObjectList objects;
	ConnectionList connections;
	VPackage vPackage;

	public SchemeLoader(File file, VPackage vp) {
		this.vPackage = vp;

		// Use an instance of ourselves as the SAX event handler
		DefaultHandler handler = new PackageHandler();

		// Use the validating parser
		SAXParserFactory factory = SAXParserFactory.newInstance();

		factory.setValidating(true);
		//path = file.getParent();

		try {
			// Parse the input
			SAXParser saxParser = factory.newSAXParser();
            db.p("heere0");
			saxParser.parse(file, handler);
		} catch (SAXException sxe) {
			// Error generated by this application (or a parser-initialization error)
			Exception x = sxe;

			if (sxe.getException() != null) {
				x = sxe.getException();
			}
			x.printStackTrace();
		} catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		} catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
		}
		db.p("doneparsing");
	} // PackageParser

	// ===========================================================
	// SAX DocumentHandler methods
	// ===========================================================
	class PackageHandler extends DefaultHandler {


		public InputSource resolveEntity(java.lang.String publicId, java.lang.String systemId) throws SAXException{
			InputSource is = null;
			db.p("heere1");
			// order the DTD to be specified externally.
			if (systemId != null && systemId.endsWith("dtd")) {
				is = new InputSource("scheme.dtd");
				db.p("heere");
			}
			return is;
		}

		public void error(SAXParseException spe) {
			// Error generated by the parser

			db.p(
				"\n** Parsing error, line " + spe.getLineNumber() + ", uri "
				+ spe.getSystemId());
			//db.p("   " + spe.getMessage());

			// Use the contained exception, if any
			Exception x = spe;

			if (spe.getException() != null) {
				x = spe.getException();
			}
			x.printStackTrace();
		}

		public void setDocumentLocator(Locator l) {// Save this to resolve relative URIs or to give diagnostics.
		}

		public void startDocument() throws SAXException {
		}

		public void endDocument() throws SAXException {
		}

		public void startElement(String namespaceURI, String lName, String qName,
								 Attributes attrs) throws SAXException {
			String element = qName;

			if (element.equals("object")) {
				String name = attrs.getValue("name");
				String type = attrs.getValue("type");
                obj = new GObj();
                obj.setName(name);
				obj.setClassName(type);
				objects.add(obj);

			}

			if (element.equals("properties")) {
				String x = attrs.getValue("x");
				String y = attrs.getValue("y");
				String xsize = attrs.getValue("xsize");
				String ysize = attrs.getValue("ysize");
                String width = attrs.getValue("width");
                String height = attrs.getValue("height");
				String strict = attrs.getValue("strict");

                obj.setX(Integer.parseInt(x));
				obj.setY(Integer.parseInt(y));
				obj.setXsize(Float.parseFloat(xsize));
				obj.setYsize(Float.parseFloat(ysize));
				obj.setWidth(Integer.parseInt(width));
				obj.setHeight(Integer.parseInt(height));
				obj.setStrict(Boolean.valueOf(strict).booleanValue());
			}

			if (element.equals("field")) {
				String name = new String(attrs.getValue("name"));
				String type = new String(attrs.getValue("type"));
				String value = new String(attrs.getValue("value"));
                ClassField cf = new ClassField();
				cf.name = name;
				cf.type = type;
				if (value != null) {
					cf.value = value;
				}
				obj.fields.add(cf);
			}

			if (element.equals("connection")) {
				String obj1 = new String(attrs.getValue("obj1"));
				String port1 = new String(attrs.getValue("port1"));
				String obj2 = new String(attrs.getValue("obj2"));
				String port2 = new String(attrs.getValue("port2"));
                Port beginPort = objects.getPort(obj1, port1);
				Port endPort = objects.getPort(obj2, port2);
				connection = new Connection(beginPort, endPort);
			}

			if (element.equals("point")) {
                String x = new String(attrs.getValue("x"));
				String y = new String(attrs.getValue("y"));
				connection.addBreakPoint(new Point(Integer.parseInt(x), Integer.parseInt(y)));			}

		}

		public void endElement(String namespaceURI, String sName, String qName) throws
				SAXException {
			if (qName.equals("object")) {
				for (int j = 0; j < vPackage.classes.size(); j++) {
					PackageClass pClass  = (PackageClass)vPackage.classes.get(j);
					if (pClass.name.equals(obj.className)) {
						obj.ports = (ArrayList) pClass.ports.clone();
						Port port;

						for (int i = 0; i < obj.ports.size(); i++) {
							port = (Port) obj.ports.get(i);
							obj.ports.set(i, port.clone());
							port = (Port) obj.ports.get(i);
							port.setObject(obj);

							if (port.isStrict()) {
								obj.strict = true;
							}

							if (port.x + port.openGraphics.boundX < obj.portOffsetX1) {
								obj.portOffsetX1 = port.x + port.openGraphics.boundX;
							}

							if (port.y + port.openGraphics.boundY < obj.portOffsetY1) {
								obj.portOffsetY1 = port.y + port.openGraphics.boundY;
							}

							if (port.x + port.openGraphics.boundWidth > obj.width + obj.portOffsetX2) {
								obj.portOffsetX2 = Math.max((port.x + port.openGraphics.boundX + port.openGraphics.boundWidth) - obj.width, 0);
							}

							if (port.y + port.openGraphics.boundHeight > obj.height + obj.portOffsetY2) {
								obj.portOffsetY2 = Math.max((port.y + port.openGraphics.boundY + port.openGraphics.boundHeight) - obj.height, 0);
							}

							// deep clone port's connectionlist
							port.connections = (ArrayList) port.connections.clone();
						}

					}
				}
			}
		/*	if (qName.equals("connections")) {
				for (int i = 0; i < connections.size(); i++) {

				}
			}*/
		}

		public void characters(char buf[], int offset, int len) throws SAXException {

		}

		public void ignorableWhitespace(char buf[], int offset, int len) throws SAXException {// Purposely ignore it.
		}

		public void processingInstruction(String target, String data) throws SAXException {// Purposely ignore it.
		}

	}

	/**
	 * Treat validation errors as fatal.
	 * SAX ErrorHandler method.
	 * @param e - SAXParseException.
	 * @throws org.xml.sax.SAXParseException -
	 */
	public void error(SAXParseException e) throws SAXParseException {
		db.p(e);
	} // error

	/**
	 * Output warnings via the debug output module.
	 * SAX ErrorHandler method.
	 * @param e - SAXParseException.
	 * @throws org.xml.sax.SAXParseException -
	 */
	public void warning(SAXParseException e) throws SAXParseException {
		db.p(
			"** Warning, line " + e.getLineNumber() + ", uri "
			+ e.getSystemId());
		db.p("   " + e.getMessage());
	} // warning
	public Scheme getScheme() {
        return null;
	}
}

package ee.ioc.cs.vsle.packageparse;

import java.io.File;
import java.io.IOException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.awt.Font;
import java.awt.Color;
import org.xml.sax.SAXParseException;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.Attributes;
import org.xml.sax.helpers.DefaultHandler;
import ee.ioc.cs.vsle.vclass.*;
import ee.ioc.cs.vsle.graphics.*;
import ee.ioc.cs.vsle.util.*;
import ee.ioc.cs.vsle.synthesize.SpecParser;

public class PackageParser {
	VPackage pack = new VPackage();
	// ArrayList classNames = new ArrayList();
	PackageClass newClass;
	Port newPort;
	ClassGraphics newGraphics;
	String element;
	String path;

	/**
	 * Statuses:
	 * 1 - class.
	 * 2 - ports and related information.
	 * 4 - package.
	 */int status;

	/**
	 * Class constructor.
	 * @param file File - package file.
	 */
	public PackageParser(File file) {

		// Use an instance of ourselves as the SAX event handler
		DefaultHandler handler = new PackageHandler();

		// Use the validating parser
		SAXParserFactory factory = SAXParserFactory.newInstance();

		factory.setValidating(true);
		path = file.getParent();

		try {
			// Parse the input
			SAXParser saxParser = factory.newSAXParser();

			saxParser.parse(file, handler);
		}
		catch (SAXException sxe) {
			// Error generated by this application (or a parser-initialization error)
			Exception x = sxe;

			if (sxe.getException() != null) {
				x = sxe.getException();
			}
			x.printStackTrace();
		}
		catch (ParserConfigurationException pce) {
			// Parser with specified options can't be built
			pce.printStackTrace();
		}
		catch (IOException ioe) {
			// I/O error
			ioe.printStackTrace();
		}
		db.p("doneparsing");
	} // PackageParser

	// ===========================================================
	// SAX DocumentHandler methods
	// ===========================================================
	class PackageHandler
		extends DefaultHandler {
		public void error(SAXParseException spe) {
			// Error generated by the parser

			db.p("\n** Parsing error, line " + spe.getLineNumber() + ", uri " + spe.getSystemId());
			db.p("   " + spe.getMessage());

			// Use the contained exception, if any
			Exception x = spe;

			if (spe.getException() != null) {
				x = spe.getException();
			}
			x.printStackTrace();
		}

		public void setDocumentLocator(Locator l) { // Save this to resolve relative URIs or to give diagnostics.
		}

		public void startDocument() throws SAXException {}

		public void endDocument() throws SAXException {}

		public void startElement(String namespaceURI, String lName, String qName, Attributes attrs) throws SAXException {
			element = qName;
			if (element.equals("package")) {
				status = 4;
			}
			if (element.equals("class")) {
				status = 1;
			}
			if (element.equals("graphics")) {
				newGraphics = new ClassGraphics();
				String showFields = attrs.getValue("showFields");

				if (showFields != null && showFields.equals("true")) {
					newGraphics.showFields = true;
				}
			}

			if (element.equals("port")) {
				status = 2;
				String name = attrs.getValue("name");
				String x = attrs.getValue("x");
				String y = attrs.getValue("y");
				String portConnection = attrs.getValue("portConnection");
				String strict = attrs.getValue("strict");

				newPort = new Port(name, Integer.parseInt(x), Integer.parseInt(y), portConnection, strict);
			}
			if (element.equals("open")) {
				status = 2;
			}
			if (element.equals("closed")) {
				status = 3;
			}
			if (element.equals("text")) {
				String str = attrs.getValue("string");
				int colorInt = Integer.parseInt(attrs.getValue("colour"));
				int x = Integer.parseInt(attrs.getValue("x"));
				int y = Integer.parseInt(attrs.getValue("y"));
				String fontName = attrs.getValue("fontname");
				int fontStyle = Integer.parseInt(attrs.getValue("fontstyle"));
				int fontSize = Integer.parseInt(attrs.getValue("fontsize"));

				db.p("string=" + str + ",colorInt=" + colorInt + ",x=" + x + ",y=" + y + ",fontName=" + fontName + ",fontStyle=" + fontStyle + ",fontSize=" + fontSize);
				Font font = new Font(fontName, fontStyle, fontSize);

				db.p("Font " + font + " created.");
				Text newText = new Text(x, y, font, new Color(colorInt), 0.0, str);

				newGraphics.addShape(newText);

			}

			/* if (element=="field") {
			 String name = attrs.getValue("name");
			 String type = attrs.getValue("type");
			 String value = attrs.getValue("defaultVal");
			 newClass.addField(new ee.ioc.cs.editor.vclass.ClassField(name, type, value));
			 }
			 */
			if (element.equals("line")) {
				String x1 = attrs.getValue("x1");
				String x2 = attrs.getValue("x2");
				String y1 = attrs.getValue("y1");
				String y2 = attrs.getValue("y2");
				String color = attrs.getValue("colour");
				Line newLine = new Line(Integer.parseInt(x1), Integer.parseInt(y1), Integer.parseInt(x2), Integer.parseInt(y2), Integer.parseInt(color), 1.0, 0.0);

				newGraphics.addShape(newLine);
			}
			if (element.equals("rect")) {
				String x = attrs.getValue("x");
				String[] split = x.split("#");

				String y = attrs.getValue("y");
				String width = attrs.getValue("width");
				String height = attrs.getValue("height");
				String color = attrs.getValue("colour");
				String filled = attrs.getValue("filled");
				Rect newRect = new Rect(Integer.parseInt(x), Integer.parseInt(y), Integer.parseInt(width), Integer.parseInt(height), Integer.parseInt(color), Boolean.valueOf(filled).booleanValue(), 1.0, 0.0);

				newGraphics.addShape(newRect);
			}
			if (element.equals("oval")) {
				String x = attrs.getValue("x");
				String y = attrs.getValue("y");
				String width = attrs.getValue("width");
				String height = attrs.getValue("height");
				String color = attrs.getValue("colour");
				String filled = attrs.getValue("filled");
				Oval newOval = new Oval(Integer.parseInt(x), Integer.parseInt(y), Integer.parseInt(width), Integer.parseInt(height), Integer.parseInt(color), Boolean.valueOf(filled).booleanValue(), 1.0, 0.0);

				newGraphics.addShape(newOval);
			}
			if (element.equals("arc")) {
				String x = attrs.getValue("x");
				String y = attrs.getValue("y");
				String width = attrs.getValue("width");
				String height = attrs.getValue("height");
				String startAngle = attrs.getValue("startAngle");
				String arcAngle = attrs.getValue("arcAngle");
				String color = attrs.getValue("colour");
				String filled = attrs.getValue("filled");
				Arc newArc = new Arc(Integer.parseInt(x), Integer.parseInt(y), Integer.parseInt(width), Integer.parseInt(height), Integer.parseInt(startAngle), Integer.parseInt(arcAngle), Integer.parseInt(color), Boolean.valueOf(filled).booleanValue(), 1.0, 0.0);

				newGraphics.addShape(newArc);
			}
			if (element.equals("bounds")) {
				String x = attrs.getValue("x");
				String y = attrs.getValue("y");
				String width = attrs.getValue("width");
				String height = attrs.getValue("height");

				newGraphics.setBounds(Integer.parseInt(x), Integer.parseInt(y), Integer.parseInt(width), Integer.parseInt(height));
			}

		}

		public void endElement(String namespaceURI, String sName, String qName) throws SAXException {
			if (qName.equals("class")) {
				pack.classes.add(newClass);
			}
			if (qName == "port") {
				if (newPort.openGraphics == null) {
					newGraphics = new ClassGraphics();
					newGraphics.addShape(new Oval( -4, -4, 8, 8, 0, false, 1.0, 0.0));
					newGraphics.addShape(new Oval( -3, -3, 6, 6, 12632256, true, 1.0, 0.0));
					newGraphics.setBounds( -4, -4, 8, 8);
					newPort.openGraphics = newGraphics;
				}
				db.p(newPort.closedGraphics);
				if (newPort.closedGraphics == null) {
					db.p("siin");
					newGraphics = new ClassGraphics();
					newGraphics.addShape(new Oval( -4, -4, 8, 8, 0, true, 1.0, 0.0));
					newGraphics.setBounds( -4, -4, 8, 8);
					newPort.closedGraphics = newGraphics;
				}

				newClass.addPort(newPort);
				status = 1;
			}

			if (qName.equals("graphics")) {
				if (status == 2) {
					newPort.openGraphics = newGraphics;
				}
				else if (status == 3) {
					newPort.closedGraphics = newGraphics;
				}
				else {
					// newGraphics.packageClass = newClass;
					newClass.addGraphics(newGraphics);

				}
			}

		}

		public void characters(char buf[], int offset, int len) throws SAXException {
			String s = new String(buf, offset, len);

			if (element.equals("name")) {
				// if we are reading a package field
				if (status == 4) {
					pack.name = s;
				}
				else { // else we a reading a class field
					newClass = new PackageClass(s);
					SpecParser sp = new SpecParser();

					try {
						newClass.fields = sp.getFields(path + File.separator + s + ".java");
					}
					catch (IOException e) {
						db.p("File read exception: class " + s + " specified in package does not exits.");
					}
					// classNames.add(s);
				}
			}
			if (element.equals("description") && status == 4) {
				pack.description = s;
			}

			if (element.equals("title")) {
				newClass.title = s;
			}
			if (element.equals("icon")) {
				newClass.icon = s;
			}

			/* if (element.equals("portname")) {
			 newPort = new ee.ioc.cs.editor.vclass.Port(s);
			 }
			 if (element.equals("type")) {
			 newPort.type = s;
			 }
			 if (element.equals("dataType")) {
			 newPort.dataType = s;
			 }
			 if (element.equals("xpos")) {
			 newPort.xPos = Integer.parseInt(s);
			 }
			 if (element.equals("ypos")) {
			 newPort.yPos = Integer.parseInt(s);
			 }*/

		}

		public void ignorableWhitespace(char buf[], int offset, int len) throws SAXException { // Purposely ignore it.
		}

		public void processingInstruction(String target, String data) throws SAXException { // Purposely ignore it.
		}

	}

	/**
	 * Treat validation errors as fatal.
	 * SAX ErrorHandler method.
	 */
	public void error(SAXParseException e) throws SAXParseException {
		db.p(e);
	} // error

	/**
	 * Output warnings via the debug output module.
	 * SAX ErrorHandler method.
	 */
	public void warning(SAXParseException err) throws SAXParseException {
		db.p("** Warning, line " + err.getLineNumber() + ", uri " + err.getSystemId());
		db.p("   " + err.getMessage());
	} // warning

	/**
	 * Parse the Java file, read the specification and make the relations accordingly.
	 *
	 */
	public VPackage getPackage() {
		return pack;
	} // getPackage

}

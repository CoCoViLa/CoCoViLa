package ee.ioc.cs.vsle.equations;import ee.ioc.cs.vsle.util.db;import java.util.HashMap;/** */class ConstNode extends ExpNode {	/**	 * Node number.	 */	String value;	/**	 * Class constructor.	 * @param val String	 */	ConstNode(String val) {		value = val;	} // ee.ioc.cs.editor.equations.ConstNode	/**	 * <UNCOMMENTED>	 */	void getExpressions() {	} // getExpressions	/**	 * <UNCOMMENTED>	 */	void getVars() {		if (!Character.isDigit(value.charAt(0))) {			EquationSolver.vars.add(value);		}	} // getVars	/**	 * <UNCOMMENTED>	 * @param upper String	 */	void getExpressions(String upper) {		String rel = "";		if (!Character.isDigit(value.charAt(0))) {			rel = value + "=" + upper + ":";			EquationSolver.vars.size();			for ( String a : EquationSolver.vars ) {				//allow the following because later we need to check for variables appearing on both sides of equation				if ( upper.indexOf(a) > 0 ) {					rel += a + " ";				}			}			rel = (rel + ":" + value).replaceAll( "\\$", "" );			EquationSolver.relations.add( rel );		}	} // getExpressions	/**	 * <UNCOMMENTED>	 * @param table -	 * @return double -	 */	double calcValue(HashMap table) {		if (!Character.isDigit(value.charAt(0))) {			Double d = (Double) table.get(value);			if (d != null) {				return d.doubleValue();			} 			System.out.println(value + " isnt assigned a value but used in equation");		} else			return Double.parseDouble(value);		return 0;	}	void leftReverse() {	} // leftReverse	/**	 * <UNCOMMENTED>	 */	void rightReverse() {	} // rightReverse	/**	 * <UNCOMMENTED>	 */	void decorate() {	} // decorate	/**	 * <UNCOMMENTED>	 * @return String	 */	String inFix() {		return value;	} // inFix	/**	 * <UNCOMMENTED>	 */	void postFix() {		db.p(value);	} // postFix}